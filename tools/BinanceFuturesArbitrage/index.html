<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binance Delivery Futures Scanner</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .container { max-width: 800px; margin: auto; }
        .price-info { margin: 20px 0; }
        .premium-positive { color: #00a960; }
        .premium-negative { color: #d9234c; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { padding: 10px; text-align: left; border-bottom: 1px solid #ddd; }
        th { background-color: #f5f5f5; }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #45a049;
        }
        .controls {
            display: flex;
            align-items: center;
        }
        /* 自定义进度条颜色 */
        #nprogress .bar {
            background: #29d; /* 进度条颜色 */
        }
        
        #nprogress .spinner-icon {
            border-top-color: #29d;
            border-left-color: #29d;
        }
        th { 
            cursor: pointer; 
            position: relative;
            padding-right: 25px !important; /* 增加右侧padding，为箭头留出空间 */
        }
        th:hover {
            background-color: #e9e9e9;
        }
        th::after {
            content: '';
            position: absolute;
            right: 8px;
            top: 50%;        /* 垂直居中 */
            transform: translateY(-50%);  /* 精确垂直居中 */
            opacity: 0.3;
            margin-left: 8px;  /* 增加与文字的间距 */
        }
        th.sortable {
            cursor: pointer;
        }
        th.sortable::after {
            content: '↕';
        }
        th.sortable.sort-asc::after {
            content: '↑';
            opacity: 1;
        }
        th.sortable.sort-desc::after {
            content: '↓';
            opacity: 1;
        }
        th.sortable:hover {
            background-color: #e9e9e9;
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>Binance Delivery Futures Arbitrage Scanner</h2>
        <div class="controls" style="margin-bottom: 20px;">
            <button onclick="fetchAllPrices()" style="padding: 8px 16px; cursor: pointer;">
                Refresh Data
            </button>
            <span id="lastUpdate" style="margin-left: 15px; color: #666;">
                Last update: -
            </span>
        </div>
        <div class="price-info">
            <table id="priceTable">
                <thead>
                    <tr>
                        <th>Symbol</th>
                        <th>Spot Price</th>
                        <th>DEC 2024</th>
                        <th>Volume</th>
                        <th>Spread</th>
                        <th>Premium</th>
                        <th>Days Left</th>
                        <th>APR</th>
                        <th>MAR 2025</th>
                        <th>Volume</th>
                        <th>Spread</th>
                        <th>Premium</th>
                        <th>Days Left</th>
                        <th>APR</th>
                    </tr>
                </thead>
                <tbody id="priceTableBody">
                </tbody>
            </table>
        </div>
    </div>

    <script>
        const BINANCE_API_BASE = 'https://api.binance.com/api/v3';
        const BINANCE_DELIVERY_API = 'https://dapi.binance.com/dapi/v1';
        const SYMBOLS = ['BTC', 'ETH', 'LINK', 'BNB', 'ADA', 'LTC', 'BCH', 'XRP', 'SOL'];
        const sortableColumns = [3, 5, 7, 9, 11, 13]; // 交易量、Premium和APR列的索引

        // 修改合约面值常量
        const CONTRACT_SIZE = {
            'BTC': 100,   // BTC交割合约一张是100美元
            'ETH': 10,    // ETH交割合约一张是10美元
            'LINK': 10,   // LINK交割合约一张是10美元
            'BNB': 10,    // BNB交割合约一张是10美元
            'ADA': 10,    // ADA交割合约一张是10美元
            'LTC': 10,    // LTC交割合约一张是10美元
            'BCH': 10,    // BCH交割合约一张是10美元
            'XRP': 10,    // XRP交割合约一张是10美元
            'SOL': 10     // SOL交割合约一张是10美元
        };

        function calculateAPR(premium, daysToExpiry) {
            return (premium / daysToExpiry) * 365;
        }

        function getDaysToExpiry(isCurrentQuarter) {
            const now = new Date();
            // JavaScript中月份从0开始计数：11表示12月
            const currentDelivery = new Date(2024, 11, 27);  // 2024年12月27日
            // 2表示3月
            const nextDelivery = new Date(2025, 2, 28);      // 2025年3月28日
            
            const targetDate = isCurrentQuarter ? currentDelivery : nextDelivery;
            const days = Math.max(1, Math.ceil((targetDate - now) / (1000 * 60 * 60 * 24)));
            return days;
        }

        function formatPremium(premium) {
            const className = premium >= 0 ? 'premium-positive' : 'premium-negative';
            return `<span class="${className}">${premium.toFixed(2)}%</span>`;
        }

        // 修改格式化交易量的函数
        const formatVolume = (volume, symbol, price) => {
            if (!volume || !price) return 'N/A';
            const contracts = parseFloat(volume.volume);
            // 计算美元价值：张数 * 合约面值
            // 注意：这里不需要乘以价格，因为合约面值已经是美元单位
            const volumeInUSD = contracts * CONTRACT_SIZE[symbol];
            // 如果金额大于1百万，显示为xx.xxM
            if (volumeInUSD >= 1000000) {
                return (volumeInUSD / 1000000).toFixed(2) + 'M';
            }
            // 如果金额大于1千，显示为xx.xxK
            if (volumeInUSD >= 1000) {
                return (volumeInUSD / 1000).toFixed(2) + 'K';
            }
            return Math.round(volumeInUSD).toLocaleString();
        };

        // 修改排序函数
        function sortTable(columnIndex, isNumber = true) {
            if (!sortableColumns.includes(columnIndex)) {
                return; // 如果不是可排序的列，直接返回
            }

            const table = document.getElementById('priceTable');
            const tbody = table.querySelector('tbody');
            const rows = Array.from(tbody.querySelectorAll('tr'));
            const th = table.querySelectorAll('th')[columnIndex];
            
            // 如果是初始加载或者刷新，直接设置为降序
            let newState = 'desc';
            
            // 如果是用户点击，则循环切换状态
            if (th.classList.contains('sort-desc')) {
                newState = 'asc';
            } else if (th.classList.contains('sort-asc')) {
                newState = null;
            }

            // 清除所有列的排序标记
            table.querySelectorAll('th').forEach(header => {
                header.classList.remove('sort-asc', 'sort-desc');
            });

            // 设置新的排序状态
            if (newState) {
                th.classList.add(`sort-${newState}`);
            }

            // 如果是默认状态，恢复原始顺序
            if (!newState) {
                // 按照symbol列的字母顺序排序作为默认顺序
                rows.sort((a, b) => {
                    return a.cells[0].textContent.localeCompare(b.cells[0].textContent);
                });
            } else {
                // 按照选中的列排序
                rows.sort((a, b) => {
                    let aValue = a.cells[columnIndex].textContent;
                    let bValue = b.cells[columnIndex].textContent;
                    
                    if (isNumber) {
                        aValue = parseValue(aValue);
                        bValue = parseValue(bValue);
                        
                        if (isNaN(aValue) && isNaN(bValue)) return 0;
                        if (isNaN(aValue)) return 1;
                        if (isNaN(bValue)) return -1;
                        
                        return newState === 'asc' ? aValue - bValue : bValue - aValue;
                    } else {
                        return newState === 'asc' ? 
                            aValue.localeCompare(bValue) : 
                            bValue.localeCompare(aValue);
                    }
                });
            }

            // 重新插入排序后的行
            rows.forEach(row => tbody.appendChild(row));
        }

        // 解析各种格式的值
        function parseValue(value) {
            if (value === 'N/A') return NaN;
            // 移除千位分隔符
            value = value.replace(/,/g, '');
            // 处理百分比
            if (value.includes('%')) {
                return parseFloat(value);
            }
            // 处理K/M后缀
            if (value.endsWith('K')) {
                return parseFloat(value) * 1000;
            }
            if (value.endsWith('M')) {
                return parseFloat(value) * 1000000;
            }
            return parseFloat(value);
        }

        // 修改初始化排序的代码
        function setupTableSorting() {
            const table = document.getElementById('priceTable');
            const headers = table.querySelectorAll('th');
            
            headers.forEach((header, index) => {
                if (sortableColumns.includes(index)) {
                    header.classList.add('sortable');
                    header.addEventListener('click', () => sortTable(index, true));
                }
            });
        }

        async function fetchAllPrices() {
            NProgress.start();
            const tableBody = document.getElementById('priceTableBody');
            tableBody.innerHTML = '';

            try {
                for (const symbol of SYMBOLS) {
                    try {
                        // 获取现货价格
                        const spotResponse = await fetch(`${BINANCE_API_BASE}/ticker/price?symbol=${symbol}USDT`);
                        const spotData = await spotResponse.json();
                        const spotPrice = parseFloat(spotData.price);

                        // 获取所有交割合约信息和交易量
                        const [deliveryPriceResponse, deliveryVolumeResponse] = await Promise.all([
                            fetch(`${BINANCE_DELIVERY_API}/ticker/price`),
                            fetch(`${BINANCE_DELIVERY_API}/ticker/24hr`)
                        ]);
                        
                        const deliveryPriceData = await deliveryPriceResponse.json();
                        const deliveryVolumeData = await deliveryVolumeResponse.json();

                        // 获取当前季度和次季度合约的价格和交易量
                        const currentQuarterSymbol = `${symbol}USD_241227`;
                        const nextQuarterSymbol = `${symbol}USD_250328`;

                        const currentQuarterContract = deliveryPriceData.find(item => item.symbol === currentQuarterSymbol);
                        const nextQuarterContract = deliveryPriceData.find(item => item.symbol === nextQuarterSymbol);

                        const currentQuarterVolume = deliveryVolumeData.find(item => item.symbol === currentQuarterSymbol);
                        const nextQuarterVolume = deliveryVolumeData.find(item => item.symbol === nextQuarterSymbol);

                        const currentQuarterPrice = currentQuarterContract ? parseFloat(currentQuarterContract.price) : 0;
                        const nextQuarterPrice = nextQuarterContract ? parseFloat(nextQuarterContract.price) : 0;

                        // 修改显示行的部分，传入价格参数
                        const currentQuarterVolumeFormatted = formatVolume(currentQuarterVolume, symbol, currentQuarterPrice);
                        const nextQuarterVolumeFormatted = formatVolume(nextQuarterVolume, symbol, nextQuarterPrice);

                        // 计算差价（Spread）
                        const currentQuarterSpread = currentQuarterPrice ? Math.abs(currentQuarterPrice - spotPrice).toFixed(2) : 'N/A';
                        const nextQuarterSpread = nextQuarterPrice ? Math.abs(nextQuarterPrice - spotPrice).toFixed(2) : 'N/A';

                        // 计算溢价率
                        const currentQuarterPremium = currentQuarterPrice ? ((currentQuarterPrice - spotPrice) / spotPrice) * 100 : 0;
                        const nextQuarterPremium = nextQuarterPrice ? ((nextQuarterPrice - spotPrice) / spotPrice) * 100 : 0;

                        const currentQuarterDays = getDaysToExpiry(true);
                        const nextQuarterDays = getDaysToExpiry(false);
                        
                        const currentQuarterAPR = calculateAPR(currentQuarterPremium, currentQuarterDays);
                        const nextQuarterAPR = calculateAPR(nextQuarterPremium, nextQuarterDays);

                        console.log(`${symbol} prices:`, {
                            spot: spotPrice,
                            currentQuarter: currentQuarterPrice,
                            nextQuarter: nextQuarterPrice
                        });

                        const row = `
                            <tr>
                                <td>${symbol}</td>
                                <td>${Math.round(spotPrice).toLocaleString()}</td>
                                <td>${currentQuarterPrice ? Math.round(currentQuarterPrice).toLocaleString() : 'N/A'}</td>
                                <td>${currentQuarterVolumeFormatted}</td>
                                <td>${currentQuarterSpread}</td>
                                <td>${currentQuarterPrice ? formatPremium(currentQuarterPremium) : 'N/A'}</td>
                                <td>${currentQuarterDays}</td>
                                <td>${currentQuarterPrice ? formatPremium(currentQuarterAPR) : 'N/A'}</td>
                                <td>${nextQuarterPrice ? Math.round(nextQuarterPrice).toLocaleString() : 'N/A'}</td>
                                <td>${nextQuarterVolumeFormatted}</td>
                                <td>${nextQuarterSpread}</td>
                                <td>${nextQuarterPrice ? formatPremium(nextQuarterPremium) : 'N/A'}</td>
                                <td>${nextQuarterDays}</td>
                                <td>${nextQuarterPrice ? formatPremium(nextQuarterAPR) : 'N/A'}</td>
                            </tr>
                        `;
                        tableBody.innerHTML += row;

                        // 更新最后刷新时间
                        const now = new Date();
                        const timeString = now.toLocaleTimeString();
                        document.getElementById('lastUpdate').textContent = `Last update: ${timeString}`;

                    } catch (error) {
                        console.error(`Error fetching ${symbol}:`, error);
                        tableBody.innerHTML += `
                            <tr>
                                <td>${symbol}</td>
                                <td colspan="9">Error fetching data: ${error.message}</td>
                            </tr>
                        `;
                    }
                }

                // 所有数据加载完成后
                const volumeColumnIndex = 3; // 第一个交易量列的索引
                sortTable(volumeColumnIndex, true); // 直接调用排序
                
                // 设置排序标记
                const volumeHeader = document.querySelector(`th:nth-child(${volumeColumnIndex + 1})`);
                if (volumeHeader) {
                    // 清除其他列的排序标记
                    document.querySelectorAll('th').forEach(header => {
                        header.classList.remove('sort-asc', 'sort-desc');
                    });
                    // 设置为降序
                    volumeHeader.classList.add('sort-desc');
                }

            } catch (error) {
                console.error('Error:', error);
                document.getElementById('lastUpdate').textContent = 
                    `Last update failed at ${new Date().toLocaleTimeString()}`;
            } finally {
                NProgress.done(); // 完成进度条
            }
        }

        // 初始加载
        fetchAllPrices();

        // 每分钟自动刷新一次（60000毫秒 = 1分钟）
        setInterval(fetchAllPrices, 60000);

        // 更新页面加载完成后的初始化代码
        document.addEventListener('DOMContentLoaded', () => {
            // 只保留设置表格排序
            setupTableSorting();
        });
    </script>
</body>
</html>